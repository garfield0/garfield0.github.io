---
layout: page
title: "简化重复工作 -- 2014年工作总结"
description: "Automate -- leave the dirty job to computer"
---
{% include JB/setup %}
重复工作是单调乏味的，但又不可避免。在工作中，我逐渐认识到，重复就意味着有模式可循，如果能够把这模式拎出来，用计算机手段描述，很多重复工作是可以简化的。简化之后，适当的组合工具，又可以自动化重复工作，这样做不仅提升了技能，也提高了工作效率。以下是我的总结和一些常用方法。

# 需求转化为工具

从最简单的工作入手。最简单是指这项工作能够用一到两句话表述清楚。如果这一两句话又能分别找到现成的工具，就相当于圆满解决了。

例1：在Data文件夹下，找到根数文件“Full Catalog-20131108T0000.tle”，查找NORAD编号为29670的两行根数。

问题可以分成两部分，一是查找文件，二是匹配字符串。解决办法有两个：一是用图形界面，在资源管理器里搜索文件，然后用编辑器打开文件，在编辑器里找到查找菜单，最后查找字符串“29670”。二是用命令行，如下：

    $ find ~/Data -name "Full Catalog-20131108T0000.tle" -exec grep "29670" {} \;

该命令的意思是，在目录“~/Data”下，find名称为“Full Catalog-20131108T0000.tle”的文件，对其执行grep操作，筛选含字符串“29670”的行。

## 命令行 VS 图形工具

工作流程拆分开以后，命令行更接近我们解决问题的思路，而使用图形工具，会增加要处理的信息和内容，分散注意力，且不利于抽象出简单的工作模式。再看上面那个例子，命令行调用了两个命令，find和grep，分别对应文件查找和字符串匹配，和解决问题的思路是对应的。图形工具则不然。需要先在资源管理器里，用人眼分辨不同的文件名，移动鼠标选中文件，用记事本打开后，还需要寻找查找字符串菜单等操作。图形工具严重依赖人眼分辨和鼠标动作，导致清晰的逻辑思路被打断。文件查找和字符串匹配中间，夹杂了需要处理的大量冗余信息，比如：该目录下有大量类似文件，定位文件会变得很困难；编辑器不熟悉，需要逐个菜单寻找所需功能等。

命令行工具小而灵活，利于累积经验，图形工具依赖性强，不易移植，重复工作不可避免。命令行通过参数来改变程序行为和结果，如果换了文件、字符串，只需要更改参数。同样的变化，图形工具需要把所有流程重复一遍，因为依靠人眼辨别、鼠标移动的操作，替代难度高，只好重来。

例2：把Music文件夹下的所有mp3文件打包。

    $ find ~/Music -name "*.mp3" -exec tar -czvf mp3.tar.gz {} +

这个问题跟上例是一类，都是查找文件，然后操作找到的文件。命令行工具改动不大，只是对find结果调用tar程序打包。解决思路可以复用，解决方法在形式上一致。但用图形工具就很困难。用眼睛一个个找是不现实的，也可以搜索后，把结果拷贝到另一个文件夹，再调用打包程序操作。这样简单问题就弄复杂了。

命令行工具在简化重复工作上有明显优势，小而灵活，解决问题思路清晰，不易受干扰，经验易累积、复用。图形工具形象直观，适合展示结果，而不适合大量使用在制造结果的过程之中。

# 用管道组合命令行工具

之前的例子中，find命令有-exec参数来操作文件。在Unix中，不同的命令行工具可以方便的用管道Pipe来组合，形成不同工具，满足多变需求。

例3：磁盘快满了，想查查是哪个文件夹占用最多。

资源管理器可以在文件夹上鼠标右键，属性里查看文件夹大小。但是，如果想知道同级所有文件夹大小，就有点捉襟见肘了，如果还想对所有同级文件夹，按大小排序，就不太可能了，用命令行可以这样：

    $ du -gd 1 . ｜ sort -n

du是显示文件夹大小，sort是排序，中间“|”是Pipe。意思就是以G为单位，显示所有下级文件夹大小，结果通过管道传递给sort程序，sort再按大小排序。

例4：有一个文本文件，每行代表一条信息，每行里有不同的参数，想要提取需要的几个参数，根据其中一个参数排序，生成新文件。

用命令行可以这样：

    $ awk '{ print $4, $2}' file.txt | sort -n 

awk从文件里提取出每行的第4、2项，传递给sort，sort根据提取出的第四项排序。

# 语言补充命令行工具

已有的工具及它们的组合都不能满足需求时，就要打造新的工具。打造工具的工具就是程序语言。

例5：对象还是三行根数文件。有很多根数文件，每个文件对应的是不同的空间目标集合。每个目标有三行信息。现在想把所有文件里高轨、低轨、中轨的分开，高、中、低轨道的判断根据根数文件里圈数这个参数来判断，设置两个标记值h、l（h>l）。圈数大于h的是低轨，小于l的是高轨，中间的是中轨。h、l值可以配置。

这个问题涉及文件查找，字符串分割提取，还要缓存字符串，写入其他文件。用脚本语言可以简单的实现。下面给出两种实现，一用脚本语言Perl，二用Lisp。

Perl程序如下：

    #!/usr/bin/env perl
    
    use strict;
    use warnings;
    
    if (@ARGV < 3) {
        print "Usage:", __FILE__, " [Low Number] [High Number] [Ele Dir]\n";
        exit;
    }
    
    my $low = shift(@ARGV);
    my $high = shift(@ARGV);
    my $eledir = shift(@ARGV);
    my $objname;
    my @Params1;
    my @Params2;
    my @tle;
    my $info;
    #
    my $fnl = "HeoObjects.txt";
    open(my $fl, '>', $fnl) or die "Could not open file '$fnl' $!";
    #
    my $fnm = "MeoObjects.txt";
    open(my $fm, '>', $fnm) or die "Could not open file '$fnm' $!";
    #
    my $fnh = "LeoObjects.txt";
    open(my $fh, '>', $fnh) or die "Could not open file '$fnh' $!";
    
    print "Ele divided to two parts: below $low and up $high.\n";
    
    opendir (my $dh, $eledir) or die "Couldn't open directory, $!";
    while (readdir $dh)
    {
        if (/^\./){
            next;
        }
    
        my $path = "$eledir/$_";
        parseEle($path);
    }
    closedir $dh;
    
    close $fl;
    close $fm;
    close $fh;
    
    sub parseEle{
        my $path = shift;
    
        open(my $fele, "<", $path) or warn "can't open < $path: $!";
    
        print "Proccessing ele file :$path\n";
        while(<$fele>){
            chomp;        
    
            #print "$_\n";
            if (/^1/){
                #@Params1 = split;
    
                $tle[1] = $_;
            }
            elsif (/^2/){
                @Params2 = split;
                #print "$_\n";
    
                $tle[2] = $_;
    
                if ($Params2[7] < $low){
                    $info = "HIGH";
    
                    print $fl "$tle[$_]\n" foreach 0 .. $#tle;
                }
                elsif($Params2[7] > $high){
                    $info = "LOW";
    
                    print $fh "$tle[$_]\n" foreach 0 .. $#tle;
                }
                else{
                    $info = "MEO";
    
                    print $fm "$tle[$_]\n" foreach 0 .. $#tle;
                }
    
                print "$objname\n";
                print " $Params2[7] -> $info\n";
            }
            else{        
                $objname = $_;
                #print "$_\n";
    
                $tle[0] = $_;
            }
    
    
        }
    
        close($fele);
    
    }

Lisp程序如下：

    ;;;; elediv.lisp
    
    (in-package #:elediv)
    
    ;;; "elediv" goes here. Hacks and glory await!
    
    (defun input-files (path)
      (directory (make-pathname :name :wild :type :wild :directory path)))
    
    (defun file-3lines-apply (file fn)
      (with-open-file (in file)
        (labels ((iter (in 3lines)
                   (let ((l (read-line in nil nil)))
                     (if (null l)
                         'done
                         (if (= (length 3lines) 3)
                             (progn ;;do with three lines
                               (funcall fn 3lines)
                               (iter in (append '() (list l))))
                             (iter in (append 3lines (list l))))))))
          (iter in '()))))
    
    
    
    (defun circles-from-3lines (3l)
      (read-from-string (eighth (tokens (third 3l) #'constituent 0))))
    
    (defun constituent (c)
      (and (graphic-char-p c)
           (not (char= c #\Space))))
    
    (defun tokens (str test start)
      (let ((p1 (position-if test str :start start)))
        (if p1
            (let ((p2 (position-if #'(lambda (c)
                                       (not (funcall test c)))
                                   str :start p1)))
    
              (cons (subseq str p1 p2)
                    (if p2
                        (tokens str test p2)
                        nil)))
            nil)))
    
    (defun elediv (low high path)
      (let ((leo (open "LeoObjects.txt" :direction :output :if-exists :supersede))
            (meo (open "MeoObjects.txt" :direction :output :if-exists :supersede))
            (heo (open "HeoObjects.txt" :direction :output :if-exists :supersede))
            (files (input-files path)))
        (labels ((write-patterns (3l)
                   (let ((circle (circles-from-3lines 3l)))
                     (cond ((< circle low) 
                            (progn 
                              ;(format t "~A~% : ~D => HEO~%" (first 3l) circle)
                              (format heo "~{~A~%~}" 3l)))
                           ((> circle high) 
                            (progn 
                              ;(format t "~A~% : ~D => LEO~%" (first 3l) circle)
                              (format leo "~{~A~%~}" 3l)))
    
                           (t 
                            (progn 
                              ;(format t "~A~% : ~D => MEO~%" (first 3l) circle)
                              (format meo "~{~A~%~}" 3l))))))
                 (parse-ele (f)
                   (file-3lines-apply f #'write-patterns)))
          (mapcar #'parse-ele files))
        (progn
          (close leo)
          (close meo)
          (close heo))
        'done))

# 组合语言和环境

一门程序语言，语法只是它的表达方式；语句下的逻辑思路，是它的语意；在什么场合使用它，是它的语境。实际项目的要求多变而复杂，想靠一门语言或工具包打天下的想法，只是一厢情愿，而且往往作茧自缚。语言和环境都只是工具。着眼于需求，组合不同的工具，比固守单一工具，成本要小得多。

例6：一台大型设备的操作配套软件。设备有下级子设备，总体功能需要各子设备配合完成。各子设备和设备之间，通过网络、文件来通信，不同功能对应不同接口。设备运作方式由控制中心下达，通过网络、文件、数据库数据来通信，也有各自接口。设备运行状态，工况信息，当前各状态与应用环境的关系，要能直观显示，且提供友好的人机交互接口。接口数目约一百，每个接口对应不同参数，参数意义和格式各不相同。操作系统需为Windows。

简单说，该软件由两个部分组成，一是数据接口，二是图形界面。

数据接口有三类：网络、文件、数据库。网络接口有文本和二进制数据。每条网络消息都可看成不同参数的组合。参数可看成字符串或二进制数据，通过加头尾标志符，以分隔符组合各参数，或各参数定长，以结构组成网络数据。文件接口大部分为文本文件，同一文件接口中每行文本格式相同，也通过分隔符、或定长字符串来区分不同参数。数据库接口涉及不同表，表中每行同样对应不同参数和数据结构。于是，此三类接口，共计约一百个，各自对应不同的数据接口。把字符串和二进制数据的打包、拆包功能，提取出统一模式，形成统一调用方式，再利用面向对象特性，每个接口可对应一个类。在源代码层面，要保证这一百个类格式正确，缩进方式统一，大小写无误，注释清晰，另外，接口变化是常事，所以一定要能方便的更改。

需要一个代码生成程序，各接口的数据结构用标记语言描述，写成配置文件，该程序读取此类文件生成对应源码。需要更改接口时，只要更改对应的配置文件，重新生成源码即可。标记语言可以选择json、xml等，再用另外的程序语言先解析，后生成源码。如果用Lisp来实现，可以进一步简化问题。先省略解析标记语言的问题，直接考虑如何生成代码。因为Lisp最基本的结构list，就可以定义结构化的数据。只要将接口数据格式的定义放在独立的lisp源文件即可。代码生成功能实现以后，如果需要统一用json或xml来重新标记，再把数据定义部分分离，加一层解析功能即可。

图形界面有两个要求，一是人机交互比较频繁，二是动态展示。操作系统要求Windows，和目标客户的知识经验有关。设备和其子设备状态参数繁多，对应的GUI控件也多，就要求GUI控件能支持模版，同类的控件可以复用，也可以很方便定义不同行为。展示是其主要功能，但后台还需处理各种接口，要对网络、文件、数据库操作有良好支持，即对网络、文件、数据库操作提供良好封装，避免处理过于琐碎的细节，并且自带Gabage Collection。Windows下，C#和.Net组合可以简化很多问题。WPF图形框架，可以用标记语言XAML定义界面和控件行为，支持资源、模版、数据绑定。.Net框架提供了网络、文件、数据库操作的封装，C#类似Java、Python，可以专注功能实现，不被内存管理等分散注意力。

于是，虽然设备要求配套软件运行在Windows下，但是，软件问题分解以后，不同的部分可以有更好的选择来实现。代码生成部分用Lisp实现的好处在于，最后不仅仅生成了C#源码，还形成了对所有接口统一的测试、配置方法。因为该程序有所有接口的数据定义，非常适合生成模拟数据来测试接口。Linux下Slime配合Lisp，效果和Python的解释器类似，可以及时反馈、迭代处理测试信息。基于网络、文件的接口操作，和使用Windows还是Linux没有分别，所以，大部分操作又可以利用linux强大的命令行和脚本能力来完成。最后结果展示，用C#结合.Net实现，圆满完成了要求。

这个例子中，组合不同的语言和环境，获得了单一工具链不能拥有的强大能力和拓展空间，提高了开发效率。解决了问题，同时简化了重复工作，可以专注于更贴近需求的问题，而不是被琐碎、冗余的其他信息打扰。
